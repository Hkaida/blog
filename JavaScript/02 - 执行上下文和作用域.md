# JavaScript 执行上下文和作用域



## 什么是执行上下文？

在 JavaScript 中，**执行上下文**（以下简称“上下文”）是一个非常重要的概念。对于理解 Javascript 引擎如何工作非常重要。那么，什么是上下文呢？

上下文是一个抽象的说法，初学者乍一听可能会很懵。其实它跟语文中的上下文是一个意思。

举个例子：

> ...
>
> 小明：“天呐！”
>
> ...

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1913642337,3077470837&fm=26&gp=0.jpg)

看，如果一篇文章摘出来一句话，没头没尾的，你读不懂这在表达啥，因为一段文字常常需要结合语境来理解意思，你必须知道这句话的前面写了什么，否则就读不下去了。文学语言有语境，编程语言亦是如此。

再结合代码的例子：

```javascript
let n = 1;

function add(num){
    num += 1;
    return num
}

add(n);
```

这里的函数 add() 需要接受一个参数 num ，这个参数num就是所需的上文，也可称作“必要的信息”，那么在调用函数add()并传入参数 n 的时候，就产生了一个上下文。函数 add 结合传进来的不同参数，返回的结果也会不一样。



## 上下文的执行顺序

上下文可以理解为一段代码的执行环境，它会形成一个作用域。JavaScript 中的上下文可分为三种：

- 全局上下文：程序启动时首先创建的是全局上下文。
- 函数上下文：函数调用时产生新的上下文，开始执行函数中的代码。
- eval上下文：不推荐使用，可忽略。

由此可见，在一个程序中肯定会出现多个上下文，而 JavaScript 引擎会用**栈**的形式来控制它们的执行顺序，这个栈可称为**函数调用栈(call stack)**。全局上下文永远在栈底，栈顶则是当前正在执行的上下文，同一时间处于活动状态的上下文只有一个。

在 JavaScript 引擎解析代码时，每遇到上面三种情况之一，都会产生一个新的上下文被推入函数调用栈中，上下文执行完毕之后就会被弹出销毁，包括其中定义的变量和函数（闭包除外），然后继续执行之前的上下文。为了更清晰地理解这个过程，请看下面代码例子以及图示的分析：

```JavaScript
// 首先是全局上下文进入函数调用栈
console.log("全局");
function fn1() {
	console.log("fn1");
    
	function fn2() {
		console.log("fn2")
		console.log("fn2 执行完毕");
	}

	fn2();
	console.log("fn1 执行完毕");
}

fn1();

// "全局"
// "fn1"
// "fn2"
// "fn2 执行完毕"
// "fn1 执行完毕"
```



![](E:\2-web前端\个人作品集\my博客图片\JavaScript\JavaScript-02-1.png)



