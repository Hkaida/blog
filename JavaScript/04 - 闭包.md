# JavaScript 闭包

## 前言

如果你想学好 JavaScript 这门语言，那么闭包就是一道绕不开的槛。对于初学者来说，这是一个令人费解的知识点。可能很多人会认为平时也没怎么用到闭包呀，闭包也没那么重要吧，于是对闭包的理解就停留在记一句概念、背一段代码的层次。事实上闭包无处不在，只是你还没发现自己曾经写的某一段代码其实就是闭包。如果不了解闭包的本质，便终究是雾里看花。

闭包既然如此重要，但为什么还会有很多人模糊不清呢？是闭包真的太难，还是大家不思进取？我认为都不是，记得在我刚接触闭包的时候，总想搞懂究竟什么是闭包，什么叫闭包，甚至在我写这篇文章的时候，我还在查阅资料，究竟有没有简单而准确地概括闭包的一句话。经典的书籍、网上的文章都有说过对闭包的定义，首先我给大家分享一些它们对闭包的描述。

**《JavaScript 高级程序设计》（第4版）**：

“闭包指的是引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。”

-

**《你不知道的 JavaScript》（上册）**：

“当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。”

-

**《JavaScript 权威指南》（第6版）**：

“从技术的角度讲，所有的 JavaScript 函数都是闭包——它们都是对象，它们都关联到作用域链。”

-

**MDN web docs：**

“一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。”

......

兜兜转转，没想到吧！所有函数都是闭包！玄之又玄的定义直接让人当场凌乱，我想很多人都不能接受这个说法。

从语言实现的角度来看，也可以说所有 JavaScript 函数都是闭包，这涉及到一些底层细节。但我暂时不会去解释这些“无趣的闭包”。

但从应用的角度来说，闭包应该是一种编程模式，这种模式能让一个内部函数在**定义时的作用域**之外执行，并且保持了访问**定义时的作用域**中的变量，这种模式的作用是把变量隐藏起来，限制以指定的方式去读写。

> 如果你对词法作用域还不太了解，请点击 → [词法作用域](https://blog.csdn.net/weixin_48276895/article/details/109325171)

## 一个普通的闭包

那么接下来我会用一个例子去诠释什么是闭包，以及闭包的意义。

假设某一个场景下，需要实现一个计数器，也许你一开始会这么写：

```javascript
let count = 0;

function add(){
    count++;
    return count;
}

add(); // 1
add(); // 2
add(); // 3
```

但是，count 是一个全局变量，这样非常地不妥，万一在代码别处被意外地修改了怎么办。我们不喜欢这种乱了套的行为出现，为了把这种意外扼杀在摇篮之中，必须把 count 隐藏起来！

利用函数 fn1() 把变量 count 封闭在函数作用域内，就能成功地阻止了外部的访问，再不用担心 count 会在别处被修改了，这将会很酷！

```javascript
function fn1(){
    let count = 0;
}
```

- **”不行啊，这样我们也不能访问 count 了！“**

好吧，那就在 fn1() 里也封装了一个函数 fn2() ，并且把 fn2() 当作一个值通过 return 命令传递出来，所以现在它多了一个名字叫 add 。

我们知道函数对象属于引用类型，看起来是在外部调用的 add() 其实只是通过不同的标识符引用调用了内部函数 fn2()，根据词法作用域的规则，fn2() 依然能够访问 fn1() 中的 count ，所以调用 add() 就可以间接访问 count 了，并且针对 count 的读写方式只能依赖于 fn2() 的实现，这将会很酷！

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        count++;
    	return count;
    }
    
    return fn2;
}

let add = fn1();
// 看，同样的调用方式，返回同样的结果！
add(); // 1
add(); // 2
add(); // 3
```

- **emmmm，不对劲，按理说 fn1() 执行完之后，其中的变量不是都销毁了吗？**

巧妙的是，垃圾回收器首先要确定某个变量不会再被使用，才会销毁它。而 add 保存了对 fn2() 的引用，并且 fn2() 会使用到 count，我们随时都可能调用 add() ，因此 count 会一直保留着，直到 fn2() 这把“钥匙”被销毁。

```javascript
add = null;
```

将 add 重新赋值为 null，解除了 add 对 fn2() 的引用，因为没有任何办法再调用 fn2() ，因此 fn2() 和 count 所占用的内存都会被释放。

看完这个例子，你可能发现了，这个几乎谈是闭包的必备例子。甚至有朋友会认为这样的函数套函数才是闭包。

这里面有闭包，但它只是利用了闭包，闭包的特性是什么？闭包能使函数总是可以访问函数外部的变量，这个总是，包括父级作用域消失之后。

再分析一下这个例子：

1. 首先目的是**隐藏**这个变量，办法是利用函数作用域使其成为局部变量。
2. 接着目的是**访问**这个变量，办法是利用闭包的特性创建一个可以访问它的子函数。
3. 最终目的是能在**外部**对变量进行访问，所以需要把子函数传递出来，而例子的方式是 return ，尽管不能以任意方式对这个变量读写了，这恰恰是最初的目的。

## 词法环境

> 接下来的内容将会从底层细节去了解闭包，虽然不了解也不会影响对闭包的使用，但缺失这一块，终究是不完整的，因为你需要知道为什么所有函数都是天生闭包的，也许某一天你就要向别人解释为什么。

JavaScript 中，每执行一段可执行代码（函数、代码块`{...}`以及全局代码）都会新创建一个与之关联的对象，被称为 **词法环境（Lexical Environment）**。词法环境是作用域的内部实现机制，俗称作用域（scopes）。

词法环境对象包含两个部分：

1. **环境记录（Environment Record）** —— 一个特殊的内部对象，存储当前代码段中声明的所有变量作为其属性（也包括一些其他信息，例如 `this`的值）。对变量的“读写”都意味着是对环境记录中的属性进行“读写”。
2. 对 **外部词法环境** 的引用（outer），与外部代码相关联，全局词法环境没有外部引用，值为 null。

#### 1. 预解析与执行时

在一段代码即将执行时，词法环境对象被创建，并收集作用域范围内的所有变量声明，存储到环境记录中，例如`let`声明的变量，最初它们会处于**未初始化（Uninitialized）**状态，这意味着引擎知道变量，但仍然要在声明语句之后使用它，这就是所谓的“预解析/预编译”，我猜你应该接触过“[变量提升](https://blog.csdn.net/weixin_48276895/article/details/109409290)”的现象，这应该会让你嗅到一丝熟悉的味道。

下表大概总结了一些声明在“预解析”时的行为：

| 声明方式    | 预解析行为           |
| ----------- | -------------------- |
| var         | 获得默认值 undefined |
| let / const | 未初始化             |
| 函数声明    | 完成初始化           |
| 函数表达式  | 与变量声明一致       |

随着代码执行过程的推进，环境记录也会随之改变，以下例子演示了这种变化：

```javascript
// 即将执行 → 全局词法环境 = { 环境记录: { a: <未初始化>, fn: function(){...} }, 外部词法环境: null }
let a; // -----------------环境记录: { a: undefined, fn: function(){...} }
a = 1; // -----------------环境记录: { a: 1, fn: function(){...} }
a = 2; // -----------------环境记录: { a: 2, fn: function(){...} }

function fn(){
    // 即将执行 → fn词法环境 = { 环境记录:{ a: <未初始化> }, 外部词法环境: 全局词法环境 }
    let a = 3; // ------------环境记录: { a: 3 }
}
fn();

if (true) {
    // 即将执行 → 块级词法环境 = { 环境记录:{ b: <未初始化> }, 外部词法环境: 全局词法环境 }
    let b = 4; // ---------------环境记录: { b: 4 }
    console.log(b + a);
}
```

#### 2. 内部和外部词法环境

函数被调用或执行代码块`{...}`的代码时，便会创建一个新的词法环境，那么在程序运行时，可能会同时存在多个词法环境。

```javascript
// 即将执行 → 全局词法环境 = { 环境记录: { a: <未初始化>, fn: function(){...} }, 外部词法环境: null }
let a = 1; // --------------环境记录: { a: 1, fn: function(){...} }

function fn(b){
    // 即将执行 → fn词法环境 = { 环境记录: { b: 2 }, 外部词法环境: 全局词法环境 }
    console.log(a + b);
}
fn(2);
```

上面例子中，函数执行时，会存在两个词法环境，内部（函数）和外部（全局），内部词法环境中引用了外部的词法环境。

**当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境为止，或者期间如果找到标识符匹配的变量便会终止查找。**

#### 3. 对外部词法环境的引用

所有函数在创建时，就已经记住了它所在的词法环境。原因是所有函数都有名为 `[[Environment]]` 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。

让我们再回到前面的计数器案例。

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        // 创建时 → [[Environment]]: fn1词法环境
        // 被调用 → fn2词法环境 = { 环境记录: {  }, 外部词法环境: [[Environment]] }
        count++;
    	return count;
    }
    
    return fn2;
}
let add = fn1();
add();
```

1. fn1() 被调用时，创建了新的 fn1 词法环境，并返回了已创建但还没调用的 fn2 函数。

2. fn2() 在创建时，通过了隐藏的 `fn2.[[Environment]]` 属性记住了它所在的词法环境。
3. add() 被调用时，实则调用的是  fn2 ()，创建新的 fn2 词法环境，其对外部词法环境的引用获取于 `fn2.[[Environment]]` 属性。
4. fn2() 在执行时，首先在自身词法环境中搜索变量 count ，显然是没有的，便根据`[[Environment]]`进入 fn1 词法环境中查找，找到了便修改 fn1 词法环境中的变量 count。

这就是**在变量所在的词法环境中更新变量。**

不管函数在何处调用，都不会改变 `[[Environment]]` 这个隐藏属性指向创建时的词法环境。因此，函数总能访问其创建时所在的词法环境中的变量。

#### 4. 同层级的词法环境

如果调用多次 fn1() ，便是创建了多个计数器，它们各自都有独立的词法环境，属于同层级的词法环境，不存在嵌套关系，互不影响。

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        count++;
    	return count;
    }
    
    return fn2;
}
let add1 = fn1();
let add2 = fn1();
add1(); // 1
add1(); // 2
add2(); // 1
```

【图】

如果 fn1() 中不止一个闭包，它们的词法环境是同层级，拥有同一个外部词法环境，它们修改获取都是同一个 count 变量。

```javascript
function fn1(){
    let count = 0;
    
    function setCount(){
        count++;
    	return count;
    }
    
    function getCount(){
        return count;
    }
    
    return { setCount, getCount };
}
let counter = fn1();
counter.getCount(); // 0
counter.setCount(); // 1
counter.getCount(); // 1
```

【图】

-

> **词法环境是一个规范对象**
>
> “词法环境”是一个规范对象（specification object）：它仅仅是存在于编程语言规范中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。
>
> 但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。

## 结合词法环境理解闭包

了解到词法环境之后，是时候重新介绍一下 JavaScript 中的闭包了。

**闭包就是一个函数和它外部词法环境的组合体，也可以用这个函数来指代闭包。**

ECMAScript中，**所有 JavaScript 的函数都是天生闭包的**，因为它们的隐藏属性`[[Environment]]` 中都引用了自身创建所在的外部词法环境，所以函数总是可以访问外部词法作用域中的变量，即使函数在父级词法作用域之外调用。

> [new Function()](https://zh.javascript.info/new-function) 创建的函数例外，因为它不管在何处创建，它的 `[[Environment]]` 总是指向全局环境。

## 实际中的优化

那么问题来了，理论上如果函数可访问时，它外部的所有变量也将继续存在。如果利用浏览器的开发者工具，在执行内部函数时把代码执行暂停，在控制台输入`console.log(value)`，是否能访问 value 呢。

```javascript
function f() {
	let value = "outer";

	function g() {
    	debugger; // 在 Console 中输入：console.log(value); 报错：value is not defined
	}
	
    return g;
}

let g = f();
g();
```

利用上面例子测试会发现，理论上这里应该是可访问的，但实际上，JavaScript 引擎会分析变量的使用情况，没有被内部函数引用的外部变量（局部变量），会被引擎优化掉。

这并不奇怪，因为外部函数 f() 已经执行结束了，而函数 g 明显没有引用 value。

另一种情况：

```javascript
let value = "全局";

function f() {
	let value = "outer";

	function g() {
    	debugger; // 在 Console 中输入：console.log(value);
	}
	
    return g;
}

let g = f();
g();
```

上面例子在 Chrome、Edge 和 Opera 浏览器中，如果全局中有定义一个同名变量 value，那么控制台会输出同名的全局变量。如果是 Firefox 浏览器会显示报错`variable 'value' has been optimized out`，指明变量 value 已经被优化掉了。

为什么我会说变量被优化而不是被销毁掉呢，外部函数执行完了肯定是被删除掉了，但如果把这个例子再修改一下，在外部函数执行结束之前执行内部函数，看看会怎么样：

```javascript
let value = "全局";

function f() {
	let value = "outer";

	function g() {
		debugger; // 在 Console 中输入：console.log(value); 输出："全局"（Firefox依然报错被优化）
	}

	g();
	console.log(value); // 输出："outer"
}

f();
```

上面例子中，在函数 g() 调用之后，还是可以访问到函数 f() 中的 value 的，而在内部函数调用时 value 还没有被销毁，却还是无法访问！

个人猜测（仅供参考），不同的 JavaScript 引擎都对没有引用外部变量的函数中的 `[[Environment]]`属性做了手脚 ，直接指向了全局环境，或者指向 null。另外如果引用了外部变量，外部词法环境中没有被引用的变量会被优化掉，也就是说，函数中的 `[[Environment]]`得到的是一个删减版的外部词法环境。

无论如何，其显性行为并不会受到多少影响，影响只是调试时的问题。

在 ECMAScript 中并没有明确规定要在什么情况之下以什么方式处理`[[Environment]]`，在理论上它们都是一样的设计，但通过上面的例子可以发现，在各种 JavaScript 引擎的实现上会进行不同程度的优化。

**因此从实践的角度上看，似乎可以有另外一种理解：函数引用了外部变量时才会形成闭包，否则该函数只是一个普通函数。**

