# JavaScript 闭包

## 前言

如果你想学好 JavaScript 这门语言，那么闭包就是一道绕不开的槛。对于初学者来说，这是一个令人费解的知识点。可能很多人会认为平时也没怎么用到闭包呀，闭包也没那么重要吧，于是对闭包的理解就停留在记一句概念、背一段代码的层次。事实上闭包无处不在，只是你还没发现自己曾经写的某一段代码其实就是闭包。如果不了解闭包的本质，便终究是雾里看花。

闭包既然如此重要，但为什么还会有很多人模糊不清呢？是闭包真的太难，还是大家不思进取？我认为都不是，记得在我刚接触闭包的时候，总想搞懂究竟什么是闭包，什么叫闭包，甚至在我写这篇文章的时候，我还在查阅资料，究竟有没有简单而准确地概括闭包的一句话。经典的书籍、网上的文章都有说过对闭包的定义，首先我给大家分享一些它们对闭包的描述。

**《JavaScript 高级程序设计》（第4版）**：

“闭包指的是引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。”

-

**《你不知道的 JavaScript》（上册）**：

“当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。”

-

**《JavaScript 权威指南》（第6版）**：

“从技术的角度讲，所有的 JavaScript 函数都是闭包——它们都是对象，它们都关联到作用域链。”

-

**MDN web docs：**

“一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。”

......

兜兜转转，没想到吧！所有函数都是闭包！玄之又玄的定义直接让人当场凌乱，我想很多人都不能接受这个说法。

从语言实现的角度来看，也可以说所有 JavaScript 函数都是闭包，这涉及到一些底层细节。但我暂时不会去解释这些“无趣的闭包”。

但从应用的角度来说，闭包应该是一种编程模式，这种模式能让一个内部函数在**定义时的作用域**之外执行，并且保持了访问**定义时的作用域**中的变量，这种模式的作用是把变量隐藏起来，限制以指定的方式去读写。

> 如果你对词法作用域还不太了解，请点击 → [词法作用域](https://blog.csdn.net/weixin_48276895/article/details/109325171)

## 一个普通的闭包

那么接下来我会用一个例子去诠释什么是闭包，以及闭包的意义。

假设某一个场景下，需要实现一个计数器，也许你一开始会这么写：

```javascript
let count = 0;

function add(){
    count++;
    return count;
}

add(); // 1
add(); // 2
add(); // 3
```

但是，count 是一个全局变量，这样非常地不妥，万一在代码别处被意外地修改了怎么办。我们不喜欢这种乱了套的行为出现，为了把这种意外扼杀在摇篮之中，必须把 count 隐藏起来！

利用函数 fn1() 把变量 count 封闭在函数作用域内，就能成功地阻止了外部的访问，再不用担心 count 会在别处被修改了，这将会很酷！

```javascript
function fn1(){
    let count = 0;
}
```

- **”不行啊，这样我们也不能访问 count 了！“**

好吧，那就在 fn1() 里也封装了一个函数 fn2() ，并且把 fn2() 当作一个值通过 return 命令传递出来，所以现在它多了一个名字叫 add 。

我们知道函数对象属于引用类型，看起来是在外部调用的 add() 其实只是通过不同的标识符引用调用了内部函数 fn2()，根据词法作用域的规则，fn2() 依然能够访问 fn1() 中的 count ，所以调用 add() 就可以间接访问 count 了，并且针对 count 的读写方式只能依赖于 fn2() 的实现，这将会很酷！

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        count++;
    	return count;
    }
    
    return fn2;
}

let add = fn1();
// 看，同样的调用方式，返回同样的结果！
add(); // 1
add(); // 2
add(); // 3
```

- **emmmm，不对劲，按理说 fn1() 执行完之后，其中的变量不是都销毁了吗？**

巧妙的是，垃圾回收器首先要确定某个变量不会再被使用，才会销毁它。而 add 保存了对 fn2() 的引用，并且 fn2() 会使用到 count，我们随时都可能调用 add() ，因此 count 会一直保留着，直到 fn2() 这把“钥匙”被销毁。

```javascript
add = null;
```

将 add 重新赋值为 null，解除了 add 对 fn2() 的引用，因为没有任何办法再调用 fn2() ，因此 fn2() 和 count 所占用的内存都会被释放。

看完这个例子，你可能发现了，这个几乎谈是闭包的必备例子。甚至有朋友会认为这样的函数套函数才是闭包。

这里面有闭包，但它只是利用了闭包，闭包的特性是什么？闭包能使函数总是可以访问函数外部的变量，这个总是，包括父级作用域消失之后。

再分析一下这个例子：

1. 首先目的是**隐藏**这个变量，办法是利用函数作用域使其成为局部变量。
2. 接着目的是**访问**这个变量，办法是利用闭包的特性创建一个可以访问它的子函数。
3. 最终目的是能在**外部**对变量进行访问，所以需要把子函数传递出来，而例子的方式是 return ，尽管不能以任意方式对这个变量读写了，这恰恰是最初的目的。

## 词法环境

> 接下来的内容将会从底层细节去了解闭包，虽然不了解也不会影响对闭包的使用，但缺失这一块，终究是不完整的，因为你需要知道为什么所有函数都是天生闭包的，也许某一天你就要向别人解释为什么。

JavaScript 中，每执行一段可执行代码（函数、代码块`{...}`以及全局代码）都会新创建一个与之关联的对象，被称为 **词法环境（Lexical Environment）**。词法环境是作用域的内部实现机制，俗称作用域（scopes）。

词法环境对象包含两个部分：

1. **环境记录（Environment Record）** —— 一个特殊的内部对象，存储当前代码段中声明的所有变量作为其属性（也包括一些其他信息，例如 `this`的值）。对变量的“读写”都意味着是对环境记录中的属性进行“读写”。
2. 对 **外部词法环境** 的引用（outer），与外部代码相关联，全局词法环境没有外部引用，值为 null。

#### 1. 预解析与执行时

在一段代码即将执行时，词法环境对象被创建，并收集作用域范围内的所有变量声明，存储到环境记录中，例如`let`声明的变量，最初它们会处于**未初始化（Uninitialized）**状态，这意味着引擎知道变量，但仍然要在声明语句之后使用它，这就是所谓的“预解析/预编译”，我猜你应该接触过“[变量提升](https://blog.csdn.net/weixin_48276895/article/details/109409290)”的现象，这应该会让你嗅到一丝熟悉的味道。

下表大概总结了一些声明在“预解析”时的行为：

| 声明方式    | 预解析行为           |
| ----------- | -------------------- |
| var         | 获得默认值 undefined |
| let / const | 未初始化             |
| 函数声明    | 完成初始化           |
| 函数表达式  | 与变量声明一致       |

随着代码执行过程的推进，环境记录也会随之改变，以下例子演示了这种变化：

```javascript
// 即将执行 → 全局词法环境 = { 环境记录: { a: <未初始化>, fn: function(){...} }, 外部词法环境: null }
let a; // -----------------环境记录: { a: undefined, fn: function(){...} }
a = 1; // -----------------环境记录: { a: 1, fn: function(){...} }
a = 2; // -----------------环境记录: { a: 2, fn: function(){...} }

function fn(){
    // 即将执行 → fn词法环境 = { 环境记录:{ a: <未初始化> }, 外部词法环境: 全局词法环境 }
    let a = 3; // ------------环境记录: { a: 3 }
}
fn();

if (true) {
    // 即将执行 → 块级词法环境 = { 环境记录:{ b: <未初始化> }, 外部词法环境: 全局词法环境 }
    let b = 4; // ---------------环境记录: { b: 4 }
    console.log(b + a);
}
```

#### 2. 内部和外部词法环境