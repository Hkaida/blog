# JavaScript 闭包

## 前言

如果你想学好 JavaScript 这门语言，那么闭包就是一道绕不开的槛。对于初学者来说，这是一个令人费解的知识点。可能很多人会认为平时也没怎么用到闭包呀，闭包也没那么重要吧，于是对闭包的理解就停留在记一句概念、背一段代码的层次。事实上闭包无处不在，只是你还没发现自己曾经写的某一段代码其实就是闭包。如果不了解闭包的本质，便终究是雾里看花。

闭包既然如此重要，但为什么还会有很多人模糊不清呢？是闭包真的太难，还是大家不思进取？我认为都不是，记得在我刚接触闭包的时候，总想搞懂究竟什么是闭包，什么叫闭包，甚至在我写这篇文章的时候，我还在查阅资料，究竟有没有简单而准确地概括闭包的一句话。经典的书籍、网上的文章都有说过对闭包的定义，首先我给大家分享一些它们对闭包的描述。

**《JavaScript 高级程序设计》（第4版）**：

“闭包指的是引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。”

-

**《你不知道的 JavaScript》（上册）**：

“当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。”

-

**《JavaScript 权威指南》（第6版）**：

“从技术的角度讲，所有的 JavaScript 函数都是闭包——它们都是对象，它们都关联到作用域链。”

-

**MDN web docs：**

“一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。”

......

兜兜转转，没想到吧！所有函数都是闭包！玄之又玄的定义直接让人当场凌乱，我想很多人都不能接受这个说法。

从语言实现的角度来看，也可以说所有 JavaScript 函数都是闭包，这涉及到一些底层细节。但我暂时不会去解释这些“无趣的闭包”。

但从应用的角度来说，闭包应该是一种编程模式，这种模式能让一个内部函数在**定义时的作用域**之外执行，并且保持了访问**定义时的作用域**中的变量，这种模式的作用是把变量隐藏起来，限制以指定的方式去读写。

> 如果你对词法作用域还不太了解，请点击 → [词法作用域](https://blog.csdn.net/weixin_48276895/article/details/109325171)

## 一个普通的闭包

那么接下来我会用一个例子去诠释什么是闭包，以及闭包的意义。

假设某一个场景下，需要实现一个计数器，也许你一开始会这么写：

```javascript
let count = 0;

function add(){
    count++;
    return count;
}

add(); // 1
add(); // 2
add(); // 3
```

但是，count 是一个全局变量，这样非常地不妥，万一在代码别处被意外地修改了怎么办。我们不喜欢这种乱了套的行为出现，为了把这种意外扼杀在摇篮之中，必须把 count 隐藏起来！

利用函数 fn1() 把变量 count 封闭在函数作用域内，就能成功地阻止了外部的访问，再不用担心 count 会在别处被修改了，这将会很酷！

```javascript
function fn1(){
    let count = 0;
}
```

- **”不行啊，这样我们也不能访问 count 了！“**

好吧，那就在 fn1() 里也封装了一个函数 fn2() ，并且把 fn2() 当作一个值通过 return 命令传递出来，所以现在它多了一个名字叫 add 。

我们知道函数对象属于引用类型，看起来是在外部调用的 add() 其实只是通过不同的标识符引用调用了内部函数 fn2()，根据词法作用域的规则，fn2() 依然能够访问 fn1() 中的 count ，所以调用 add() 就可以间接访问 count 了，并且针对 count 的读写方式只能依赖于 fn2() 的实现，这将会很酷！

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        count++;
    	return count;
    }
    
    return fn2;
}

let add = fn1();
// 看，同样的调用方式，返回同样的结果！
add(); // 1
add(); // 2
add(); // 3
```

- **emmmm，不对劲，按理说 fn1() 执行完之后，其中的变量不是都销毁了吗？**

巧妙的是，垃圾回收器首先要确定某个变量不会再被使用，才会销毁它。而 add 保存了对 fn2() 的引用，并且 fn2() 会使用到 count，我们随时都可能调用 add() ，因此 count 会一直保留着，直到 fn2() 这把“钥匙”被销毁。

```javascript
add = null;
```

将 add 重新赋值为 null，解除了 add 对 fn2() 的引用，因为没有任何办法再调用 fn2() ，因此 fn2() 和 count 所占用的内存都会被释放。

上面的例子就是闭包，它满足了两点：

1. 隐藏了内部函数 fn2() 的外部变量 count ，限制外部对其的读写

2. 内部函数 fn2() 可以在其定义时的作用域（fn1）之外被调用

这，就是闭包！