# JavaScript 闭包



> 如果你对词法作用域还不太了解，请点击 → [词法作用域](https://blog.csdn.net/weixin_48276895/article/details/109325171)

## 为什么需要闭包？

假设某一个场景下，需要实现一个计数器，也许你一开始会这么写：

```javascript
let count = 0;

function add(){
    count += 1;
    return count;
}

add(); // 1
add(); // 2
add(); // 3
```

但是，count 是一个全局变量，这样非常地不妥，万一在代码别处被意外地修改了怎么办。我们不喜欢这种乱了套的行为出现，为了把这种意外扼杀在摇篮之中，必须把 count 隐藏起来！

利用函数 fn1() 把变量 count 封闭在函数作用域内，就能成功地阻止了外部的访问，再不用担心 count 会在别处被修改了，这将会很酷！

```javascript
function fn1(){
    let count = 0;
}
```

- **”不行啊，这样我们也不能访问 count 了！“**

好吧，那就在 fn1() 里也封装了一个函数 fn2() ，并且把 fn2() 当作一个值通过 return 命令传递出来，所以现在它多了一个名字叫 add 。

我们知道函数对象属于引用类型，看起来是在外部调用的 add() 其实只是通过不同的标识符引用调用了内部函数 fn2()，根据词法作用域的规则，fn2() 能够访问 count ，所以调用 add() 就可以间接访问 count 了，并且针对 count 的读写方式只能依赖于 fn2() 的实现，这将会很酷！

```javascript
function fn1(){
    let count = 0;
    
    function fn2(){
        count += 1;
    	return count;
    }
    
    return fn2;
}

let add = fn1();
// 看，同样的调用方式，返回同样的结果！
add(); // 1
add(); // 2
add(); // 3
```

- **emmmm，不对劲，按理说 fn1() 执行完之后，其中的变量不是都销毁了吗？**

巧妙的是，垃圾回收器首先要确定某个变量不会再被使用，才会销毁它。而 add 保存了对 fn2() 的引用，并且 fn2() 会使用到 count，我们随时都可能调用 add() ，因此 count 会一直保留着。

闭包是基于词法作用域书写代码时所产生的自然结果，很多时候不经意地就写出了闭包，而往往缺少的只是如何识别它。

这就是闭包的好处，用来隐藏变量，但还可以间接访问。