# JavaScript 函数



## 函数概述

函数的作用就是把程序中许多相似的操作封装起来，达到复用的目的，需要时调用一下函数即可，不需要再编写过多的重复代码，大大简化了后续相似的操作。

JavaScript 中 ，函数是一等公民



## 函数声明

函数使用 function 关键字来声明，基本语法如下：

```javascript
function 函数名(参数1, 参数2, ...) {
    // 代码编写在这里
    
    return value;
}
```

可以通过函数名加上`()`来调用函数，示例如下：

```javascript
function sayHi() {
	console.log('Hello!');
}

sayHi(); // 输出 'Hello!' 
sayHi(); // 可复用
```

--

## 作用域

函数会形成一个作用域，换句话说就是，函数中声明的变量只在该函数内部可见。

```javascript
function fn() {
    let a = 1;
    console.log(a); 
}
fn();// 输出 1
console.log(a); // 报错，外部无法访问函数内部的变量
```

外部无法访问函数内部的变量，但是函数可以访问外部的变量，也可以对其修改。

```javascript
let a = 1;

function fn() {
    a += 1;
    console.log(a); 
}

fn();// 输出 2
console.log(a); // 2 ，外部的 a 已经被修改
```

如果函数内部声明了跟外部同名的变量，它们不在同一个作用域中，是不同的两个变量。函数中调用访问同名变量时，会使用函数内部变量而忽略外部变量。

> 在函数之外声明的变量（也不在{}之内）被称为全局变量，它属于全局作用域。全局变量在所有函数中都是可见的，但是也有弊端——它们有被意外修改的风险，尽量减少全局变量的使用是一种很好的做法。
>
> 想要了解更多关于作用域的内容，请参见 → [作用域](https://blog.csdn.net/weixin_48276895/article/details/109325171)

--

## 参数

我们可以通过参数将数据传递给函数，通过传递的数据影响执行结果，使函数更灵活、复用性更强。

```javascript
function sayHi(name) {
	console.log( 'Hello ' + name + '!');
}

sayHi('Benoist'); // 输出 'Hello Benoist!' 
```

这个例子中，name 也是函数中声明的变量，调用函数时，传递的数据会根据位置分别赋值给 name 。

声明函数时使用的参数被称为**形参**，调用函数时传入的被称为**实参**。上面例子中，`name` 是形参，传入的 `'Benoist'` 是实参。

--

#### 默认参数

如果调用函数时，缺少提供实参，那么形参默认值为 `undefined`。

有时候我们想要主动设置默认值，在 ES6 之前没有很直接的方式，只能采用变通的方式：

```javascript
function sayHi(name) {
    name = name || 'everyone';
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

通过检查参数值的方式判断有没有赋值，上面的做法虽然简便，但缺点在于如果传入的参数对应布尔值为 `false` ，就不起作用了。需要更精确的话可以用 `if` 语句：

```javascript
function sayHi(name) {
	if (typeof name === 'undefined') {
		name = 'everyone';
	}
	console.log( 'Hello ' + name + '!');
}
```

ES6 提供了设置默认值的方式，就像这样：

```javascript
function sayHi(name = 'everyone') {
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

默认值不但可以是一个值，它还可以是一个表达式：

```javascript
function sayHi(name = foo()) {
	console.log( 'Hello ' + name + '!');
}

function sayHi(name = 'every'+'one') {
	console.log( 'Hello ' + name + '!');
}
```

--

## 返回值

函数中可以使用 `return` 关键字将一个值作为调用的结果返回。例如：

```javascript
function sum(num1, num2) {
    return num1 + num2;
}

let result = sum(1, 2); // 用变量来接收返回的值

console.log(result); // 3
```

`return` 关键字是可选的，它有两个作用：

1. 指定返回值。如果不使用 return ，或者用 return 而不指定返回的值，则默认返回 `undefined` 。
2. 结束函数的执行。当函数执行到 return 语句，函数会立即停止执行并退出，return 语句后面哪怕还有代码也不会继续执行。

```javascript
function fn1(){
    
}
function fn2(){
    return
}

console.log( fn1() === undefined ); // ture
console.log( fn2() === undefined ); // ture
```

`return `可以在函数中存在多个，例如：

```javascript
function diff(num1, num2) {
    if (num1 < num2) {
        return num2 - num1; // 若条件符合则执行此条语句，
    }
    
    return num1 - num2;
}

diff(1,2); // 1
diff(3,1); // 2
```

上面例子中，当 `num1 < num2` 成立，则执行完第一条 return 语句并终止函数执行，否则执行第二条 return 语句。

**注意**！不要在 return 和返回值之间换行。对于返回一条比较长的表达式，你可能会出于可读性的目的把它放在新的一行，但是：

```javascript
return // 等于 return;
	(some + long + expression + or + whatever * f(a) + f(b))
```

这样不行，因为 JavaScript 默认会在 return 语句最后加上分号`;`，实际上这样会返回 `undefined`。如果实在想跨行，那么应该在 `return` 这一行开始写，或者按照如下方式加上括号：

```javascript
return (
	some + long + expression
	+ or +
	whatever * f(a) + f(b)
	)
```





> 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如 果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。 

--

## 其他

函数复用性的特点十分明显，通常会认为用函数只是封装多次使用的代码，但把一个逻辑相关的代码封装在一起也很有用，即使只调用一次。例如下面一个获取随机整数的函数：

```javascript
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //不含最大值，含最小值
}

let result = getRandomInt(1, 10);
```

只需要把关注点放在 `let result = getRandomInt(1, 10);` 语句上，代码结构更为清晰，可读性更强。

--

## 其他形式的函数

JavaScript 中创建函数的方式有多种。

--

#### **函数表达式**

在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值。因此，有另一种创建函数的方式被称为**函数表达式**。就像这样：

```javascript
let sayHi = function() {
	console.log('Hello!');
}
```

可以看到这种创建函数的方式和其他赋值一样，把函数赋值给一个变量。不管函数是采用何种定义方式，都只是一个存储在变量 `sayHi` 的值。

函数表达式和函数声明在使用上是基本等同的，唯一的不同就是在预解析时，它们的“提升”行为不同。

函数声明：会提升整个函数体，所以能在定义之前调用。

函数表达式：跟其他变量一样，只提升标识符，不提升其初始化。

>想要了解更多关于预解析时 “提升” 的内容，请参见 → [变量提升和函数提升](