# JavaScript 函数参数

--

## 参数传递

我们可以通过参数将数据传递给函数，通过传递的数据影响执行结果，使函数更灵活、复用性更强。

```javascript
function sum(a, b) {
    console.log(a + b);
}

sum(1, 2); // 输出 3
```

这个例子中，`a` 和 `b` 属于函数中的局部变量，只能在函数中访问。调用函数时，传递的数据会根据位置来匹配对应，分别赋值给 `a` 和 `b`。

声明函数时，`function` 关键字后面括号中设定的参数被称为**形参**；调用函数时，函数名后面括号中传入的被称为**实参**。上面例子中，`a` 和 `b` 是形参，传入的 `1` 和 `2` 是实参。

因为参数是已声明的变量，所以不能再用 `let` 和 `const` 重复声明。

```javascript
function foo(a) {
    let a = 1;
}
// 报错，a 已声明

function foo(b) {
    const b = 1;
}
// 报错，b 已声明
```

JavaScript 中所有函数传递都是按值传递的，不会按引用传递。所谓的值，就是指直接保存在变量上的值，如果把对象作为参数传递，那么这个值就是这个对象的引用，而不是对象本身。换句话说就是，给函数传递参数时，相当于**从一个变量赋值到另一个变量**。

原始值：

```javascript
function add(num) {
    return num + 1;
}

let count = 5;
let result = add(count); // 此处参数传递的过程可以看作是 num = count

console.log(count); // 5
console.log(result); // 6
```

引用值：

```javascript
function setName(obj) {
    obj.name = "小明";
}

let person = {};

setName(person); // 此处参数传递的过程可以看作是 obj = person;
console.log(person); // {name: "小明"}
```

--

## 理解参数

JavaScript 函数不会检测参数的类型，甚至不会检测传入参数的个数。定义函数时设置两个形参，不意味着调用时必须传入两个参数。实际调用时不管是传了一个还是三个，甚至不传参数也不会报错。

之所以会这样，是因为传入的参数都被收集到函数内部的一个数组，我们可以通过 `arguments` 来访问它们。

它是一个名为 `arguments` 的特殊的**类数组对象**（不是 `Array` 的实例）。我们可以通过它按照数组的索引访问方式获取所有实参，也可以访问它的 `arguments.length` 属性来确定函数实际调用时传入的参数个数。

例如：

```javascript
function foo(a, b) {
	console.log(arguments[0]);
    console.log(arguments[1]);
    console.log(arguments.length);
}

foo(10, 20); // 依次输出 10、20、2 
```

上面例子中，foo() 函数的第一个参数是 a，第二个参数是b ，可以通过 arguments[x] 的方式来分别获取同样的值 。因此，你甚至可以在声明函数时不设置形参。

```javascript
function foo() {
	console.log(arguments[0]);
    console.log(arguments[1]);
}

foo(10, 20); // 依次输出 10、20 
```

由此可见，JavaScript 函数的形参只是方便使用才写出来的。想传多少个参数都不会产生错误。

还有一个要注意的是，arguments 可以跟形参一起使用，并且 arguments 对象中的值会同步到对应的形参。例如：

```javascript
function foo(a) {
	arguments[0] ++;
    console.log(a);
}

foo(10); // 输出 11
```

当修改了 arguments[0] 的值时，a 也被改变了。这并不意味着它们访问同一个内存地址，毕竟我们传入的是一个原始值。它们在内存中还是分开的，只是由于内部的机制使它们的值保持了同步。

另外，如果只传了一个参数，然后在函数中把 arguments[1] 设置为某个值，这个值并不会同步给第二个形参，就像这样：

```javascript
function foo(a,b) {
    arguments[1] = 2;
    console.log(b);
}

foo(1); // 输出 undefined
```

这个例子中，形参 b 没有传入实参，它的值会默认为 `undefined`。

**严格模式**下，`arguments` 对象中的值和形参不会再同步，当然，如果传入的是引用值，它们依然会互相影响，但这只是引用值的特性而已。

#### 箭头函数中没有 arguments

如果函数是使用箭头语法定义的，那么函数中是没有 arguments 对象的，只能通过定义的形参来访问。

```javascript
let foo = () => {
    console.log(arguments[0]);
}

foo(); // 报错，arguments 未定义
```

在某些情况可能会访问到 `arguments` ：

```javascript
function fn1(){
    let fn2 = () => {
    	console.log(arguments[0]);
    }
    
    fn2();
}

fn1(5);
```

但这个 `arguments`，并不是箭头函数的，而是属于外部普通函数的，当箭头函数中访问 `arguments` 时，顺着作用域链找到了外部函数的`arguments`。

--

## 默认参数

我们已经知道，如果调用函数时，缺少提供实参，那么形参默认值为 `undefined`。

有时候我们想要设置默认值，在 ES6 之前还不支持显式地设置默认值，只能采用变通的方式：

```javascript
function sayHi(name) {
    name = name || 'everyone';
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

通过检查参数值的方式判断有没有赋值，上面的做法虽然简便，但缺点在于如果传入的参数对应布尔值为 `false` ，就不起作用了。需要更精确的话可以用 `if` 语句，判断参数是否等于 `undefined`，如果是则说明这个参数缺少传递 ：

```javascript
function sayHi(name) {
	if (typeof name === 'undefined') {
		name = 'everyone';
	}
	console.log( 'Hello ' + name + '!');
}
```

ES6 就方便了许多，因为它支持了显式的设置默认值的方式，就像这样：

```javascript
function sayHi(name = 'everyone') { // 定义函数时，直接给形参赋值
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

默认值不但可以是一个值，它还可以是一个表达式：

```javascript
function sayHi(name = foo()) {
	console.log( 'Hello ' + name + '!');
}

function sayHi(name = 'every'+'one') {
	console.log( 'Hello ' + name + '!');
}
```

函数参数的默认值只有在函数调用时，缺少传递参数才会求值，不会在函数定义时求值。

--

#### 默认参数的位置

通常我们给参数设置默认值，是为了调用函数时可以适当省略参数的传入，这里要注意的是，有多个参数时，设置了默认值的参数如果不是放在尾部，实际上它是无法省略的。

```javascript
function fn(x = 1, y) {
	console.log([x, y]);
}

fn(); // 输出 [1, undefined]
fn(2); // 输出 [2, undefined]
fn(, 2); // 报错
fn(undefined, 2); // 输出 [1, 2]
```

上面例子中，给形参 x 设置的默认值就显得没有任何意义了。因此，设置默认值的参数都放在尾部是最好的做法：

```javascript
function fn(x, y = 2, z = 3) {
	console.log([x, y, z]);
}

fn(1); // 输出 [1, 2, 3]
fn(1, 1) // 输出 [1, 1, 3]
```

--

#### 默认参数的作用域与暂时性死区

一旦有参数设置了默认值，那么它们会形成自己的作用域，因此不能引用函数体中的变量：

```javascript
function foo(a = b) {
    let b = 1;
}

foo(); // 报错，b 未定义
```

但这个作用域只是临时的，参数初始化完毕后，这个作用域就不存在了。它也符合普通作用域的规则，上面例子中，如果存在一个全局变量 b，那么参数 a 会获取到全局变量 b 的值。

-----

给多个参数设置默认值，它们会按顺序初始化的，遵循“暂时性死区”的规则，即前面的参数不能引用后面的参数：

```javascript
function foo(a = b, b = 2) {
    return a + b;
}

foo(); // 报错，b 在初始化之前不能访问
```

--

## 参数的扩展与收集

剩余参数（rest）

ES6 提供了剩余参数的语法（`...变量名`），它可以收集函数多余的参数，这样就不再需要使用 `arguments`  对象来获取了。三个点搭配的变量是一个数组，多余的参数都会被放进这个数组中。

```javascript
function sum(...values) {
    let sum = 0;
    
    for (let val of values) {
        sum += val;
    }
    
    return sum;
}

sum(1, 2, 3);
```



剩余参数和 `arguments `对比，尽管 `arguments` 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 `arguments.map(...)` 等方法。它不同于 `arguments`  对象，它完全是 Array 的实例。



