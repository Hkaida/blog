# JavaScript 函数参数

--

## 参数传递

我们可以通过参数将数据传递给函数，通过传递的数据影响执行结果，使函数更灵活、复用性更强。

```javascript
function sum(a, b) {
    console.log(a + b);
}

sum(1, 2); // 输出 3
```

这个例子中，`a` 和 `b` 属于函数中的局部变量，只能在函数中访问。调用函数时，传递的数据会根据位置来匹配对应，分别赋值给 `a` 和 `b`。

创建函数时，`function 函数名` 后面括号中设定的参数被称为**形参**；调用函数时，函数名后面括号中传入的被称为**实参**。上面例子中，`a` 和 `b` 是形参，传入的 `1` 和 `2` 是实参。

因为参数是已声明的变量，所以不能再用 `let` 和 `const` 重复声明。

```javascript
function foo(a) {
    let a = 1;
}
// 报错，a 已声明

function foo(b) {
    const b = 1;
}
// 报错，b 已声明
```

JavaScript 中所有函数传递都是按值传递的，不会按引用传递。所谓的值，就是指直接保存在变量上的值，如果把对象作为参数传递，那么这个值就是这个对象的引用，而不是对象本身。换句话说就是，给函数传递参数时，相当于**从一个变量赋值到另一个变量**。

原始值：

```javascript
function add(num) {
    return num + 1;
}

let count = 5;
let result = add(count); // 此处参数传递的过程可以看作是 num = count

console.log(count); // 5
console.log(result); // 6
```

引用值：

```javascript
function setName(obj) {
    obj.name = "小明";
}

let person = {};

setName(person); // 此处参数传递的过程可以看作是 obj = person;
console.log(person); // {name: "小明"}
```

--

## 理解参数

JavaScript 函数不会检测参数的类型，甚至不会检测传入参数的个数。定义函数时设置两个形参，不意味着调用时必须传入两个参数。实际调用时不管是传了一个还是三个，甚至不传参数也不会报错。

之所以会这样，是因为传入的参数都被收集到函数内部的一个数组，我们可以通过 `arguments` 来访问它们。

它是一个名为 `arguments` 的特殊的**类数组对象**（不是 `Array` 的实例）。我们可以通过它按照数组的索引访问方式获取所有实参，也可以访问它的 `arguments.length` 属性来确定函数实际调用时传入的参数个数。

例如：

```javascript
function foo(a, b) {
	console.log(arguments[0]);
    console.log(arguments[1]);
    console.log(arguments.length);
}

foo(10, 20); // 依次输出 10、20、2 
```

上面例子中，foo() 函数的第一个参数是 a，第二个参数是b ，可以通过 arguments[x] 的方式来分别获取同样的值 。因此，你甚至可以在声明函数时不设置形参。

```javascript
function foo() {
	console.log(arguments[0]);
    console.log(arguments[1]);
}

foo(10, 20); // 依次输出 10、20 
```

由此可见，JavaScript 函数的形参只是方便使用才写出来的。想传多少个参数都不会产生错误。

还有一个要注意的是，arguments 可以跟形参一起使用，并且 arguments 对象中的值会同步到对应的形参。例如：

```javascript
function foo(a) {
	arguments[0] ++;
    console.log(a);
}

foo(10); // 输出 11
```

当修改了 arguments[0] 的值时，a 也被改变了。这并不意味着它们访问同一个内存地址，毕竟我们传入的是一个原始值。它们在内存中还是分开的，只是由于内部的机制使它们的值保持了同步。

另外，如果只传了一个参数，然后在函数中把 arguments[1] 设置为某个值，这个值并不会同步给第二个形参，就像这样：

```javascript
function foo(a,b) {
    arguments[1] = 2;
    console.log(b);
}

foo(1); // 输出 undefined
```

这个例子中，形参 b 没有传入实参，它的值会默认为 `undefined`。

**严格模式**下，`arguments` 对象中的值和形参不会再同步，当然，如果传入的是引用值，它们依然会互相影响，但这只是引用值的特性而已。

#### 箭头函数中没有 arguments

如果函数是使用箭头语法定义的，那么函数中是没有 arguments 对象的，只能通过定义的形参来访问。

```javascript
let foo = () => {
    console.log(arguments[0]);
}

foo(); // 报错，arguments 未定义
```

在某些情况可能会访问到 `arguments` ：

```javascript
function fn1(){
    let fn2 = () => {
    	console.log(arguments[0]);
    }
    
    fn2();
}

fn1(5);
```

但这个 `arguments`，并不是箭头函数的，而是属于外部普通函数的，当箭头函数中访问 `arguments` 时，顺着作用域链找到了外部函数的`arguments`。

--

## 参数默认值

我们已经知道，如果调用函数时，缺少提供实参，那么形参默认值为 `undefined`。

有时候我们想要设置默认值，在 ES6 之前还不支持显式地设置默认值，只能采用变通的方式：

```javascript
function sayHi(name) {
    name = name || 'everyone';
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

通过检查参数值的方式判断有没有赋值，上面的做法虽然简便，但缺点在于如果传入的参数对应布尔值为 `false` ，就不起作用了。需要更精确的话可以用 `if` 语句，判断参数是否等于 `undefined`，如果是则说明这个参数缺少传递 ：

```javascript
function sayHi(name) {
	if (typeof name === 'undefined') {
		name = 'everyone';
	}
	console.log( 'Hello ' + name + '!');
}
```

ES6 就方便了许多，因为它支持了显式的设置默认值的方式，就像这样：

```javascript
function sayHi(name = 'everyone') { // 定义函数时，直接给形参赋值
	console.log( 'Hello ' + name + '!');
}

sayHi(); // 输出 'Hello everyone!' 
```

默认值不但可以是一个值，它还可以是一个表达式：

```javascript
function sayHi(name = foo()) {
	console.log( 'Hello ' + name + '!');
}

function sayHi(name = 'every'+'one') {
	console.log( 'Hello ' + name + '!');
}
```

函数参数的默认值只有在函数调用时，缺少传递参数才会求值，不会在函数定义时求值。

--

#### 参数默认值的位置

通常我们给参数设置默认值，是为了调用函数时可以适当省略参数的传入，这里要注意的是，有多个参数时，设置了默认值的参数如果不是放在尾部，实际上它是无法省略的。

```javascript
function fn(x = 1, y) {
	console.log([x, y]);
}

fn(); // 输出 [1, undefined]
fn(2); // 输出 [2, undefined]
fn(, 2); // 报错
fn(undefined, 2); // 输出 [1, 2]
```

上面例子中，给形参 x 设置的默认值就显得没有任何意义了。因此，设置默认值的参数都放在尾部是最好的做法：

```javascript
function fn(x, y = 2) {
	console.log([x, y]);
}

fn(); // 输出 [undefined, 2]
fn(1); // 输出 [1, 2]
fn(1, 1) // 输出 [1, 1]
```

--

#### 参数的省略问题

在多个参数设置了默认值的情况下，那么问题又来了，你并不能省略比较靠前的参数，而只给最后的一个参数传入实参。

```javascript
function fn(x, y = 2, z = 3) {
	console.log([x, y, z]);
}

fn(1, , 10) // 报错
```

需要给参数设置默认值，也要解决位置限制的问题，那就只能以对象作为实参传入给函数，通过对象的属性名来匹配形参了。

##### 参数默认值和 Object.assign() 结合使用

```javascript
function fn(obj = {}) {
    let defaultObj = {
        x: undefined,
        y: 2,
        z: 3
    }
    
    obj = Object.assign(defaultObj, obj);
    
	console.log([obj.x, obj.y, obj.z]);
}

fn(); // 输出 [undefined, 2, 3]
fn({ x: 1, z: 10 }); // 输出 [1, 2, 10]
```

上面的例子中，在函数中定义了一个对象 `defaultObj` ，利用其中的属性作为参数的默认值，然后利用 [Object.assagin()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 把传入的实参对象和默认对象进行合并。同时形参 `obj`  也设置了默认值为一个空对象，防止函数调用时不传任何参数，因为这会导致 Object.assign() 接收的第二个参数是 `undefined` ，导致合并对象时产生报错。问题得到了解决，但这还不是最优解。

##### 参数默认值和解构赋值结合使用

使用ES6 的[解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)进行参数传递会更方便：

```javascript
function fn({ x, y = 2, z = 3 }) {
    console.log([x, y, z]);
}

 // 输出 [1, 2, 10]
```

在这个例子中，使用的只是对象的解构赋值默认值，还没有使用函数参数的默认值。如果函数调用时不传任何参数，也会产生报错，因为这导致了参数初始化时解构赋值失败，相当于执行了 `{x, y = 2, z = 3} = undefined`  这样的代码。

同样的，你可以利用默认参数的语法，给 `{x, y = 2, z = 3}` 设置一个默认的解构对象，使得不传参函数也能够顺利执行：

```javascript
function fn({ x, y = 2, z = 3 } = {}) {
    console.log([x, y, z]);
}

fn(); // 输出 [undefined, 2, 3]
```

这里出现了双重的默认值，可能有些绕，那么用一段伪代码来解释以上的参数初始化过程就是：

```javascript
if( 实参 === {...} ) { // 当 fn({...});
            
    { x, y = 2, z = 3 } = {...};
                           
} else if ( 实参 === undefined ){ // 当 fn();
    
    { x, y = 2, z = 3 } = {};
    
}
```

--

#### 默认参数的作用域与暂时性死区

一旦有参数设置了默认值，那么它们会形成自己的作用域，因此不能引用函数体中的变量：

```javascript
function foo(a = b) {
    let b = 1;
}

foo(); // 报错，b 未定义
```

但这个作用域只是临时的，参数初始化完毕后，这个作用域就不存在了。它也符合普通作用域的规则，上面例子中，如果存在一个全局变量 b，那么参数 a 会获取到全局变量 b 的值。

-----

给多个参数设置默认值，它们会按顺序初始化的，遵循“暂时性死区”的规则，即前面的参数不能引用后面的参数：

```javascript
function foo(a = b, b = 2) {
    return a + b;
}

foo(); // 报错，b 在初始化之前不能访问
```

--

## 参数的展开与收集

#### 剩余参数

ES6 提供了**剩余参数（rest）**的语法（`...变量名`），它可以收集函数多余的参数，这样就不再需要使用 `arguments`  对象来获取了。三个点搭配的变量是一个数组，多余的参数都会被放进这个数组中。

剩余参数基本用法：

```javascript
function sum(...values) {
    let sum = 0;
    
    for (let val of values) {
        sum += val;
    }
    
    return sum;
}

sum(1, 2, 3); // 6
```

下面是分别用 `arguments` 对象和剩余参数来获取多余参数的对比例子：

```javascript
// arguments 的写法
function sortNumbers() {
	return Array.prototype.slice.call(arguments).sort();
}

// 剩余参数的写法
const sortNumbers = (...numbers) => {
    return numbers.sort();
}
```

可以看出剩余参数的写法更加简洁。

剩余参数和 `arguments `对比，尽管 `arguments` 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，当我们使用 `arguments ` 时，如果想要调用数组方法，就必须使用`Array.prototype.slice.call`先将其转为数组。

而剩余参数它不同于 `arguments`  对象，它完全是 Array 的实例，能够很方便地使用数组方法。并且箭头函数也支持剩余参数。

另外，使用剩余参数不会影响 `arguments` 对象的功能，它仍然能够反映调用函数时传入的参数。

##### 剩余参数的位置

剩余参数必须是最后一个形参，否则会报错。

```javascript
// 报错
function fn1(a, ...rest, b) {
	console.log([a, b, rest]);
} 

// 正确写法
function fn2(a, b, ...rest) {
    console.log([a, b, rest]);
}

fn2(1, 2, 3, 4) // 输出 [1, 2, [3, 4]]
```

调用函数传入多个参数时，前面的实参会根据位置匹配赋值给形参，有多余的实参都被收集到剩余参数中。

#### 扩展参数

前面我们知道了如何把多余的参数收集为一个数组，但有时候我们需要做一些相反的事，例如要把一个数组中的元素分别传入给某个函数，而不是传入一个数组，例如：

```javascript
function sum(...values) {
    let sum = 0;
    
    for (let val of values) {
        sum += val;
    }
    
    return sum;
}

let arr = [1, 2, 3, 4];

sum(arr); // "01,2,3,4"
```

上面例子的函数会把所有传进来的数值累加，如果直接传入一个数组，就得不到我们想要的结果。

因为函数剩余参数 values 的值是 `[[1, 2, 3, 4]]`，数组 values 中只有一个元素，而这个元素的类型是数组。那么函数返回值就是数值 `0` 和数组 `[1, 2, 3, 4]`相加的结果了，两者各自进行了类型的隐式转换变成字符串，然后再相加，是一个字符串拼接的效果。

要实现把数组拆解传入给函数，首先不可能一个个传入参数——`sum(arr[0], arr[1], arr[2], arr[3]);  `，因为不是任何时候都知道数组中有多少个元素的，而且数组中可能会非常多的元素，手动传不完。

比较可行的是借助 apply() 方法：

```javascript
sum.apply(null, arr); // 10
```

但这还不是最优解，那么重点来了！

在 ES6 中，新加入了**扩展操作符（spread）**来帮助我们解决这种情况。它也是使用 `...变量名` 的语法，虽然跟剩余参数语法一样，但是用途完全相反，它能够把一个可迭代对象拆分成逗号分隔的参数序列。

在函数调用时，它的应用是这样子的：

```javascript
sum(...arr); // 10
```

它甚至可以随意搭配常规值使用，没有前后位置限制，还可以同时传入多个可迭代对象：

```javascript
sum(-1, ...arr); // 9
sum(...arr, 5); // 15
sum(-1, ...arr, 5); // 14
sum(-1, ...arr, ...[5, 6, 7]); // 27
```

扩展操作符相当于替我们完成了手动分别传参的操作，函数只知道接收的实参是单独的一个个值，不会因为扩展操作符的存在而产生其他影响。

当然它也不仅是只限于函数调用时使用，任何需要展开可迭代对象的表达式中都可以使用，例如合并数组：

```javascript
let arr = [1, 2, 3];
let arr2 = [5, 6, 7];

let merged = [...arr, 4, ...arr2];

console.log(merged); // [1, 2, 3, 4, 5, 6, 7]
```

上面的示例虽然都是针对于数组的，但也指出了是**展开可迭代对象**。所以利用扩展操作符来展开字符串也没问题：

```javascript
let str = "Hello";

console.log( [...str] ); // H,e,l,l,o
```

--

> 扩展操作符也称展开操作符，上面只是介绍了它的一部分应用场景，如果想要深入了解的话可以参见 → [扩展操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

--

## 总结

